---
import MainLayout from '../layouts/MainLayout.astro';
import { getEntry } from 'astro:content';
import TableOfContents from '../components/TableOfContents.astro';

const guideEntry = await getEntry('docs', 'ruby-on-whales');

if (!guideEntry) {
  throw new Error("Could not find ruby-on-whales document in content collection");
}

const { Content, headings } = await guideEntry.render();

// Filter headings to include only h2 and h3 (depth 2 and 3)
const tocHeadings = headings.filter(heading => heading.depth <= 3);

// Check if we have headings to show
const hasHeadings = tocHeadings && tocHeadings.length > 0;
---

<MainLayout 
  title="Ruby on Whales!" 
  description="A guide to Ruby and Docker from a pirate perspective"
  ogImage="/images/lfp2-og.jpg"
>
  <div class="markdown-content overflow-hidden w-full dark:bg-[#080f1d]">
    <Content />
  </div>
</MainLayout>

<script is:inline>
  // Check if device is mobile - run simpler code on mobile
  const isMobile = window.innerWidth <= 768;

  // Process the table of contents
  document.addEventListener('DOMContentLoaded', () => {
    const contentSection = document.querySelector('.markdown-content');
    if (!contentSection) return;
    
    // Find the manual TOC section - look for the exact heading text from the markdown
    const tocHeader = Array.from(contentSection.querySelectorAll('h2')).find(
      h2 => h2.textContent?.includes('Table of Contents')
    );
    
    if (tocHeader) {
      // Find the TOC list (it should be the next ul after the tocHeader)
      let tocList = tocHeader.nextElementSibling;
      
      // Keep searching for the next list until we find a ul or run out of elements
      while (tocList && tocList.tagName !== 'UL') {
        tocList = tocList.nextElementSibling;
      }
      
      // If found, remove both the header and the list
      if (tocList) {
        // We've confirmed we found the manual TOC, so remove it
        tocHeader.remove();
        tocList.remove();
      }
    }
    
    // Check for any empty table-of-contents divs and hide them
    const emptyTocs = document.querySelectorAll('.table-of-contents:not(:has(li))');
    emptyTocs.forEach(toc => {
      toc.style.display = 'none';
    });
  });

  // Make external links open in new tabs
  document.addEventListener('DOMContentLoaded', () => {
    const externalLinks = document.querySelectorAll('.markdown-content a[href^="http"]');
    externalLinks.forEach(link => {
      if (!link.hasAttribute('target')) {
        link.setAttribute('target', '_blank');
        link.setAttribute('rel', 'noopener noreferrer');
      }
    });
  });

  // Process command line code blocks to style prefixes - simpler on mobile
  document.addEventListener('DOMContentLoaded', () => {
    // On mobile, use simplified code without wrapper creation and animations
    if (isMobile) {
      // Do minimal styling only
      const commandBlocks = document.querySelectorAll('pre code.language-bash, pre code.language-sh');
      commandBlocks.forEach(block => {
        const content = block.innerHTML;
        // Replace common command line prefixes with styled spans
        const processedContent = content
          .replace(/^(\$ )/gm, '<span class="command-line-prefix">$</span>')
          .replace(/^(> )/gm, '<span class="command-line-prefix">></span>')
          .replace(/^(# )/gm, '<span class="command-line-prefix">#</span>');
        
        block.innerHTML = processedContent;
      });
      return;
    }
    
    // Desktop - full styling
    // Style command line prefixes
    const commandBlocks = document.querySelectorAll('pre code.language-bash, pre code.language-sh');
    
    commandBlocks.forEach(block => {
      const content = block.innerHTML;
      // Replace common command line prefixes with styled spans
      const processedContent = content
        .replace(/^(\$ )/gm, '<span class="command-line-prefix">$</span>')
        .replace(/^(> )/gm, '<span class="command-line-prefix">></span>')
        .replace(/^(# )/gm, '<span class="command-line-prefix">#</span>');
      
      block.innerHTML = processedContent;
    });

    // Fix inconsistent styling between pages - SKIP ON MOBILE
    document.querySelectorAll('.markdown-content pre, .prose pre').forEach(pre => {
      if (!pre.parentElement.classList.contains('code-block-wrapper')) {
        // If this pre isn't already wrapped, wrap it
        const code = pre.querySelector('code');
        if (code) {
          // Create wrapper
          const wrapper = document.createElement('div');
          wrapper.className = 'code-block-wrapper';
          
          // Create header
          const header = document.createElement('div');
          header.className = 'code-header';
          
          // Create copy button
          const copyBtn = document.createElement('button');
          copyBtn.className = 'copy-button';
          copyBtn.textContent = 'Copy';
          copyBtn.addEventListener('click', () => {
            const text = code.textContent || '';
            navigator.clipboard.writeText(text).then(() => {
              copyBtn.textContent = 'Copied!';
              copyBtn.classList.add('copied');
              setTimeout(() => {
                copyBtn.textContent = 'Copy';
                copyBtn.classList.remove('copied');
              }, 2000);
            });
          });
          
          // Assemble the elements
          header.appendChild(copyBtn);
          
          // Replace the pre with our wrapper structure
          pre.parentNode.insertBefore(wrapper, pre);
          wrapper.appendChild(header);
          wrapper.appendChild(pre);
        }
      }
    });
  });
</script>

<style is:global>
  /* Remove all page-specific style overrides - we'll use global.css for everything */
  /* This ensures consistency between pages */
</style> 